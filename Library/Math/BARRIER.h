#pragma once

#include <pybind11/pybind11.h>
#include <pybind11/eigen.h>

namespace py = pybind11;
namespace JGSL {

template <bool elastic>
inline void Barrier(double d, double dHat, double kappa[], double& b)
{
    if constexpr (!elastic) {
        b = -kappa[0] * (d - dHat) * (d - dHat) * log(d / dHat);
    }
    else {
        // double d_div_dHat = d / dHat;
        // double log_d_div_dHat = std::log(d_div_dHat);
        // b = kappa[0] / 2 * (d_div_dHat + 2 * std::pow(d_div_dHat, -kappa[2]) - 3) + 
        //     (-kappa[0] / 2 + kappa[1] / 8 * (1 - 2 * kappa[2]) * log_d_div_dHat) * (1 - 2 * kappa[2]) * log_d_div_dHat;
        b = -kappa[0] * std::pow(d / dHat - 1, 2) * log(d / dHat);
    }
}

template <bool elastic>
inline void Barrier_Gradient(double d1, double dHat1, double kappa[], double& g)
{
    if constexpr (!elastic) {
        double t2;

        /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
        /*     19-Jun-2019 15:02:54 */
        t2 = d1 - dHat1;
        g = kappa[0] * (t2 * std::log(d1 / dHat1) * -2.0 - (t2 * t2) / d1);
    }
    else {
        // g = (kappa[1] * (1 - 2 * kappa[2]) * std::log(d1 / dHat1) - 2 * kappa[0]) * (1 - 2 * kappa[2]) / (4 * d1) + 
        //     kappa[0] * (1 - 2 * kappa[2] * std::pow(dHat1 / d1, kappa[2] + 1)) / (2 * dHat1);
        double one_over_dHat = 1 / dHat1;
        double t2 = d1 * one_over_dHat - 1;
        g = kappa[0] * (t2 * one_over_dHat * std::log(d1 * one_over_dHat) * -2.0 - (t2 * t2) / d1);
    }
}

template <bool elastic>
inline void Barrier_Hessian(double d1, double dHat1, double kappa[], double& H)
{
    if constexpr (!elastic) {
        double t2;

        /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
        /*     19-Jun-2019 15:02:54 */
        t2 = d1 - dHat1;
        H = kappa[0] * ((std::log(d1 / dHat1) * -2.0 - t2 * 4.0 / d1) + 1.0 / (d1 * d1) * (t2 * t2));
    }
    else {
        // double one_m_2nu = 1 - 2 * kappa[2];
        // H = ((-kappa[1] * std::log(d1 / dHat1) + kappa[1]) * one_m_2nu * one_m_2nu
        //     + 2 * kappa[0] * (one_m_2nu + 2 * kappa[2] * std::pow(dHat1 / d1, kappa[2]) * (kappa[2] + 1))) / (4 * d1 * d1);
        double t2 = d1 - dHat1;
        H = kappa[0] * ((std::log(d1 / dHat1) * -2.0 - t2 * 4.0 / d1) + 1.0 / (d1 * d1) * (t2 * t2)) / (dHat1 * dHat1);
    }
}

}