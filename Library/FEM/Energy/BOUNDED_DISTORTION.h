#pragma once

namespace JGSL {

template <class T>
void g_bd(T K1, T s01, T s21, T g[2])
{
  T t3;
  T t6;
  T t8;
  T t9;
  T t10;
  T t11;

  /* G_BD */
  /*     G = G_BD(K1,S01,S21) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
  /*     25-Dec-2020 15:44:48 */
  t3 = 1.0 / s21;
  t6 = 1.0 / (K1 - 1.0);
  t8 = K1 + -(s01 * t3);
  t9 = 1.0 / t8;
  t10 = t6 * t8;
  t11 = std::log(t10);
  g[0] = -t3 * t6 * t11 - t3 * t9 * (t10 - 1.0);
  t8 = s01 * (t3 * t3);
  g[1] = t8 * t6 * t11 + t8 * t9 * (t10 - 1.0);
}

template <class T>
void H_bd(T K1, T s01, T s21, T H[4])
{
  T t4;
  T t5;
  T t9;
  T t11;
  T t12;
  T t14;
  T t13;
  T t15;
  T t22_tmp;
  T b_t22_tmp;

  /* H_BD */
  /*     H = H_BD(K1,S01,S21) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
  /*     25-Dec-2020 15:44:48 */
  t4 = 1.0 / s21;
  t5 = t4 * t4;
  t9 = 1.0 / (K1 - 1.0);
  t11 = K1 + -(s01 * t4);
  t12 = 1.0 / t11;
  t14 = t9 * t11;
  t13 = t12 * t12;
  t15 = std::log(t14);
  t22_tmp = s01 * pow(t4, 3.0);
  t11 = t5 * t9;
  b_t22_tmp = t22_tmp * t9;
  t4 = ((-(b_t22_tmp * t12 * 2.0) + t11 * t15) + t5 * t12 * (t14 - 1.0)) +
    t22_tmp * t13 * (t14 - 1.0);
  H[0] = t11 * t12 * 2.0 - t5 * t13 * (t14 - 1.0);
  H[1] = t4;
  H[2] = t4;
  t11 = s01 * s01 * (t5 * t5);
  H[3] = ((b_t22_tmp * t15 * -2.0 - t22_tmp * t12 * (t14 - 1.0) * 2.0) + t11 *
          t9 * t12 * 2.0) - t11 * t13 * (t14 - 1.0);
}

template<class T, int dim>
void Compute_Strain_Condition(
    MESH_ELEM<dim>& Elem, T h,
    T K, T stiffness,
    const std::vector<bool>& DBCb,
    MESH_NODE<T, dim>& X,
    MESH_NODE_ATTR<T, dim>& nodeAttr,
    MESH_ELEM_ATTR<T, dim>& elemAttr,
    FIXED_COROTATED<T, dim>& elasticityAttr,
    std::vector<T>& strainCondition)
{
    strainCondition.resize(Elem.size);
    Elem.Join(elemAttr).Par_Each([&](int id, auto data) {
        auto &[elemVInd, IB, P] = data;
        if (!DBCb[elemVInd[0]] || !DBCb[elemVInd[1]] || !DBCb[elemVInd[2]] || !DBCb[elemVInd[3]]) {
            const VECTOR<T, dim>& x1 = std::get<0>(X.Get_Unchecked(elemVInd[0]));
            const VECTOR<T, dim>& x2 = std::get<0>(X.Get_Unchecked(elemVInd[1]));
            const VECTOR<T, dim>& x3 = std::get<0>(X.Get_Unchecked(elemVInd[2]));
            const VECTOR<T, dim>& x4 = std::get<0>(X.Get_Unchecked(elemVInd[3]));

            MATRIX<T, dim> A;
            for (int d = 0; d < dim; ++d) { 
                A(d, 0) = x2[d] - x1[d];
                A(d, 1) = x3[d] - x1[d];
                A(d, 2) = x4[d] - x1[d];
            }
            MATRIX<T, dim> F = A * IB;
            MATRIX<T, dim> U(1), V(1);
            VECTOR<T, dim> sigma;
            Singular_Value_Decomposition(F, U, sigma, V); //TODO: not redo everytime

            if (sigma[2] <= 0) {
                strainCondition[id] = K + 1;
            }
            else {
                strainCondition[id] = sigma[0] / sigma[2];
            }
        }
        else {
            strainCondition[id] = 1;
        }
    });
}

template<class T, int dim>
bool Compute_BD_Energy(
    MESH_ELEM<dim>& Elem, T h,
    T K, T stiffness,
    const std::vector<bool>& DBCb,
    MESH_NODE<T, dim>& X,
    MESH_NODE_ATTR<T, dim>& nodeAttr,
    MESH_ELEM_ATTR<T, dim>& elemAttr,
    FIXED_COROTATED<T, dim>& elasticityAttr,
    T& E)
{
    TIMER_FLAG("Compute_BD_Energy");
    bool valid = true;
    if constexpr (dim == 2) {
        //TODO
    }
    else {
        //TODO: parallelize
        Elem.Join(elasticityAttr).Each([&](int id, auto data) {
            auto &[elemVInd, F_, vol, lambda, mu] = data;
            if (!DBCb[elemVInd[0]] || !DBCb[elemVInd[1]] || !DBCb[elemVInd[2]] || !DBCb[elemVInd[3]]) {
                const VECTOR<T, dim>& x1 = std::get<0>(X.Get_Unchecked(elemVInd[0]));
                const VECTOR<T, dim>& x2 = std::get<0>(X.Get_Unchecked(elemVInd[1]));
                const VECTOR<T, dim>& x3 = std::get<0>(X.Get_Unchecked(elemVInd[2]));
                const VECTOR<T, dim>& x4 = std::get<0>(X.Get_Unchecked(elemVInd[3]));
                const MATRIX<T, dim>& IB = std::get<FIELDS<MESH_ELEM_ATTR<T, dim>>::IB>(elemAttr.Get_Unchecked(id));

                MATRIX<T, dim> A;
                for (int d = 0; d < 3; ++d) { 
                    A(d, 0) = x2[d] - x1[d];
                    A(d, 1) = x3[d] - x1[d];
                    A(d, 2) = x4[d] - x1[d];
                }
                MATRIX<T, dim> F = A * IB;
                MATRIX<T, dim> U(1), V(1);
                VECTOR<T, dim> sigma;
                Singular_Value_Decomposition(F, U, sigma, V); //TODO: not redo everytime

                if (sigma[2] <= 0 || sigma[0] / sigma[2] >= K) {
                    valid = false;
                }
                else {
                    T weight = h * h * vol * stiffness;
                    T a = (K - sigma[0] / sigma[2]) / (K - 1);
                    E += weight * (a - 1) * std::log(a);
                }
            }
        });
    }
    return valid;
}

template<class T, int dim>
void Compute_BD_Gradient(
    MESH_ELEM<dim>& Elem, T h,
    T K, T stiffness,
    const std::vector<bool>& DBCb,
    MESH_NODE<T, dim>& X,
    MESH_NODE_ATTR<T, dim>& nodeAttr,
    MESH_ELEM_ATTR<T, dim>& elemAttr,
    FIXED_COROTATED<T, dim>& elasticityAttr)
{
    TIMER_FLAG("Compute_BD_Gradient");
    if constexpr (dim == 2) {
        //TODO
    }
    else {
        //TODO: parallelize
        Elem.Join(elasticityAttr).Each([&](int id, auto data) {
            auto &[elemVInd, F_, vol, lambda, mu] = data;
            if (!DBCb[elemVInd[0]] || !DBCb[elemVInd[1]] || !DBCb[elemVInd[2]] || !DBCb[elemVInd[3]]) {
                const VECTOR<T, dim>& x1 = std::get<0>(X.Get_Unchecked(elemVInd[0]));
                const VECTOR<T, dim>& x2 = std::get<0>(X.Get_Unchecked(elemVInd[1]));
                const VECTOR<T, dim>& x3 = std::get<0>(X.Get_Unchecked(elemVInd[2]));
                const VECTOR<T, dim>& x4 = std::get<0>(X.Get_Unchecked(elemVInd[3]));
                const MATRIX<T, dim>& IB = std::get<FIELDS<MESH_ELEM_ATTR<T, dim>>::IB>(elemAttr.Get_Unchecked(id));

                MATRIX<T, dim> A;
                for (int d = 0; d < 3; ++d) { 
                    A(d, 0) = x2[d] - x1[d];
                    A(d, 1) = x3[d] - x1[d];
                    A(d, 2) = x4[d] - x1[d];
                }
                MATRIX<T, dim> F = A * IB;
                MATRIX<T, dim> U(1), V(1);
                VECTOR<T, dim> sigma;
                Singular_Value_Decomposition(F, U, sigma, V); //TODO: not redo everytime
                Eigen::Matrix<T, dim, dim> matrixU, matrixV;
                for (int i = 0; i < dim; ++i) {
                    for (int j = 0; j < dim; ++j) {
                        matrixU(i, j) = U(i, j);
                        matrixV(i, j) = V(i, j);
                    }
                }

                T weight = h * h * vol * stiffness;

                T db_div_dS[2];
                g_bd<T>(K, sigma[0], sigma[2], db_div_dS);

                Eigen::Matrix<T, dim, dim> db_div_dF = 
                    matrixU.col(0) * (weight * db_div_dS[0] * matrixV.col(0).transpose()) +
                    matrixU.col(2) * (weight * db_div_dS[1] * matrixV.col(2).transpose());

                Eigen::Matrix<T, dim * (dim + 1), 1> db_div_dx;
                db_div_dx.template segment<dim>(0) = -(IB(0, 0) + IB(1, 0) + IB(2, 0)) * db_div_dF.col(0) - 
                    (IB(0, 1) + IB(1, 1) + IB(2, 1)) * db_div_dF.col(1) - (IB(0, 2) + IB(1, 2) + IB(2, 2)) * db_div_dF.col(2);
                db_div_dx.template segment<dim>(3) = IB(0, 0) * db_div_dF.col(0) + IB(0, 1) * db_div_dF.col(1) + IB(0, 2) * db_div_dF.col(2);
                db_div_dx.template segment<dim>(6) = IB(1, 0) * db_div_dF.col(0) + IB(1, 1) * db_div_dF.col(1) + IB(1, 2) * db_div_dF.col(2);
                db_div_dx.template segment<dim>(9) = IB(2, 0) * db_div_dF.col(0) + IB(2, 1) * db_div_dF.col(1) + IB(2, 2) * db_div_dF.col(2);
                for (int v = 0; v < dim + 1; ++v) {
                    VECTOR<T, dim>& g = std::get<FIELDS<MESH_NODE_ATTR<T, dim>>::g>(nodeAttr.Get_Unchecked(elemVInd[v]));
                    for (int d = 0; d < dim; ++d) {
                        g[d] += db_div_dx[v * dim + d];
                    }
                }
            }
        });
    }
}

template <class T>
void Compute_DU_And_DV_Div_DF(
    const Eigen::Matrix<T, 3, 3>& U,
    const VECTOR<T, 3>& sigma,
    const Eigen::Matrix<T, 3, 3>& V,
    Eigen::Matrix<T, 9, 9>& dU_div_dF, 
    Eigen::Matrix<T, 9, 9>& dV_div_dF)
{
    dU_div_dF.setZero();
    dV_div_dF.setZero();
    for (int cI = 0; cI < 3; ++cI) {
        int cI_post = (cI + 1) % 3;

        Eigen::Matrix<T, 2, 2> coefMtr;
        if (std::abs(sigma[cI] - sigma[cI_post]) < 2e-6) {
            coefMtr << sigma[cI] + 1e-6, sigma[cI_post] - 1e-6,
                sigma[cI_post] - 1e-6, sigma[cI] + 1e-6;
        }
        else {
            coefMtr << sigma[cI], sigma[cI_post],
                sigma[cI_post], sigma[cI];
        }
        const Eigen::FullPivLU<Eigen::Matrix<T, 2, 2>> solver(coefMtr);

        Eigen::Matrix<T, 2, 1> b;
        for (int rowI = 0; rowI < 3; ++rowI) {
            for (int colI = 0; colI < 3; ++colI) {
                b << U(rowI, cI_post) * V(colI, cI),
                    -U(rowI, cI) * V(colI, cI_post);
                const Eigen::Matrix<T, 2, 1> wij21 = solver.solve(b);

                dU_div_dF.template block<3, 1>(cI * 3, rowI + colI * 3) += wij21[0] * U.col(cI_post);
                dU_div_dF.template block<3, 1>(cI_post * 3, rowI + colI * 3) += -wij21[0] * U.col(cI);

                dV_div_dF.template block<3, 1>(cI * 3, rowI + colI * 3) += -wij21[1] * V.col(cI_post);
                dV_div_dF.template block<3, 1>(cI_post * 3, rowI + colI * 3) += wij21[1] * V.col(cI);
            }
        }
    }
}

template <class T, int dim = 3>
void Check_DU_And_DV_Div_DF(const MATRIX<T, 3>& F)
{
    MATRIX<T, dim> U(1), V(1);
    VECTOR<T, dim> sigma;
    Singular_Value_Decomposition(F, U, sigma, V);
    Eigen::Matrix<T, dim, dim> matrixU, matrixV;
    for (int i = 0; i < dim; ++i) {
        for (int j = 0; j < dim; ++j) {
            matrixU(i, j) = U(i, j);
            matrixV(i, j) = V(i, j);
        }
    }

    Eigen::Matrix<T, 9, 9> dU_div_dF_sym, dV_div_dF_sym;
    Compute_DU_And_DV_Div_DF(matrixU, sigma, matrixV, dU_div_dF_sym, dV_div_dF_sym);

    T eps = 1e-6;
    Eigen::Matrix<T, 9, 9> dU_div_dF_FD, dV_div_dF_FD;
    for (int rowI = 0; rowI < 3; ++rowI) {
        for (int colI = 0; colI < 3; ++colI) {
            MATRIX<T, dim> Fperturb = F;
            Fperturb(rowI, colI) += eps;

            MATRIX<T, dim> Up(1), Vp(1);
            VECTOR<T, dim> sigmap;
            Singular_Value_Decomposition(Fperturb, Up, sigmap, Vp);
            
            MATRIX<T, dim> dU = (Up - U) / eps;
            MATRIX<T, dim> dV = (Vp - V) / eps;
            for (int i = 0; i < 3; ++i) {
                for (int j = 0; j < 3; ++j) {
                    dU_div_dF_FD(i + j * 3, rowI + colI * 3) = dU(i, j);
                    dV_div_dF_FD(i + j * 3, rowI + colI * 3) = dV(i, j);
                }
            }
        }
    }

    printf("dU_div_dF error: %le %le\n", (dU_div_dF_FD - dU_div_dF_sym).norm(), (dU_div_dF_FD - dU_div_dF_sym).norm() / dU_div_dF_FD.norm());
    printf("dV_div_dF error: %le %le\n", (dV_div_dF_FD - dV_div_dF_sym).norm(), (dV_div_dF_FD - dV_div_dF_sym).norm() / dV_div_dF_FD.norm());
}

template <class T, int dim = 3>
void Check_D2b_Div_DF2(const MATRIX<T, 3>& F, T K)
{
    MATRIX<T, dim> U(1), V(1);
    VECTOR<T, dim> sigma;
    Singular_Value_Decomposition(F, U, sigma, V);
    
    Eigen::Matrix<T, 2, 9> dS_div_dF;
    for (int i = 0; i < dim; ++i) {
        for (int j = 0; j < dim; ++j) {
            dS_div_dF(0, i + j * dim) = U(i, 0) * V(j, 0);
            dS_div_dF(1, i + j * dim) = U(i, 2) * V(j, 2);
        }
    }

    Eigen::Matrix<T, dim, dim> matrixU, matrixV;
    for (int i = 0; i < dim; ++i) {
        for (int j = 0; j < dim; ++j) {
            matrixU(i, j) = U(i, j);
            matrixV(i, j) = V(i, j);
        }
    }
    Eigen::Matrix<T, 9, 9> dU_div_dF;
    Eigen::Matrix<T, 9, 9> dV_div_dF;
    Compute_DU_And_DV_Div_DF<T>(matrixU, sigma, matrixV, dU_div_dF, dV_div_dF);

    Eigen::Matrix<T, 9, 9> d2s_div_dF2[2];
    for (int i = 0; i < dim; ++i) {
        for (int j = 0; j < dim; ++j) {
            d2s_div_dF2[0].row(i + j * dim) = dU_div_dF.row(i) * V(j, 0) + U(i, 0) * dV_div_dF.row(j);
            d2s_div_dF2[1].row(i + j * dim) = dU_div_dF.row(6 + i) * V(j, 2) + U(i, 2) * dV_div_dF.row(6 + j);
        }
    }

    T db_div_dS[2];
    Eigen::Matrix<T, 2, 2> d2b_div_dS2;
    g_bd<T>(K, sigma[0], sigma[2], db_div_dS);
    H_bd<T>(K, sigma[0], sigma[2], d2b_div_dS2.data());

    Eigen::Matrix<T, dim * dim, dim * dim> d2b_div_dF2;
    d2b_div_dF2 = dS_div_dF.transpose() * (d2b_div_dS2) * dS_div_dF + 
        db_div_dS[0] * d2s_div_dF2[0] + db_div_dS[1] * d2s_div_dF2[1];

    Eigen::Matrix<T, dim, dim> db_div_dF = 
        matrixU.col(0) * (db_div_dS[0] * matrixV.col(0).transpose()) +
        matrixU.col(2) * (db_div_dS[1] * matrixV.col(2).transpose());
    T eps = 1e-6;
    Eigen::Matrix<T, dim * dim, dim * dim> d2b_div_dF2_FD;
    for (int rowI = 0; rowI < 3; ++rowI) {
        for (int colI = 0; colI < 3; ++colI) {
            MATRIX<T, dim> Fperturb = F;
            Fperturb(rowI, colI) += eps;

            MATRIX<T, dim> Up(1), Vp(1);
            VECTOR<T, dim> sigmap;
            Singular_Value_Decomposition(Fperturb, Up, sigmap, Vp);

            T db_div_dSp[2];
            g_bd<T>(K, sigmap[0], sigmap[2], db_div_dSp);

            Eigen::Matrix<T, dim, dim> matrixUp, matrixVp;
            for (int i = 0; i < dim; ++i) {
                for (int j = 0; j < dim; ++j) {
                    matrixUp(i, j) = Up(i, j);
                    matrixVp(i, j) = Vp(i, j);
                }
            }
            Eigen::Matrix<T, dim, dim> db_div_dFp = 
                matrixUp.col(0) * (db_div_dSp[0] * matrixVp.col(0).transpose()) +
                matrixUp.col(2) * (db_div_dSp[1] * matrixVp.col(2).transpose());
            
            d2b_div_dF2_FD.template block<1, 3>(rowI + colI * 3, 0) = (db_div_dFp.col(0) - db_div_dF.col(0)).transpose() / eps;
            d2b_div_dF2_FD.template block<1, 3>(rowI + colI * 3, 3) = (db_div_dFp.col(1) - db_div_dF.col(1)).transpose() / eps;
            d2b_div_dF2_FD.template block<1, 3>(rowI + colI * 3, 6) = (db_div_dFp.col(2) - db_div_dF.col(2)).transpose() / eps;
        }
    }

    printf("d2b_div_dF2 error: %le %le\n", (d2b_div_dF2_FD - d2b_div_dF2).norm(), (d2b_div_dF2_FD - d2b_div_dF2).norm() / d2b_div_dF2_FD.norm());
}

template <class T, int dim = 3>
void Check_D2s_Div_DF2(const MATRIX<T, 3>& F)
{
    MATRIX<T, dim> U(1), V(1);
    VECTOR<T, dim> sigma;
    Singular_Value_Decomposition(F, U, sigma, V);
    
    Eigen::Matrix<T, 2, 9> dS_div_dF;
    for (int i = 0; i < dim; ++i) {
        for (int j = 0; j < dim; ++j) {
            dS_div_dF(0, i + j * dim) = U(i, 0) * V(j, 0);
            dS_div_dF(1, i + j * dim) = U(i, 2) * V(j, 2);
        }
    }

    Eigen::Matrix<T, dim, dim> matrixU, matrixV;
    for (int i = 0; i < dim; ++i) {
        for (int j = 0; j < dim; ++j) {
            matrixU(i, j) = U(i, j);
            matrixV(i, j) = V(i, j);
        }
    }
    Eigen::Matrix<T, 9, 9> dU_div_dF;
    Eigen::Matrix<T, 9, 9> dV_div_dF;
    Compute_DU_And_DV_Div_DF<T>(matrixU, sigma, matrixV, dU_div_dF, dV_div_dF);

    Eigen::Matrix<T, 9, 9> d2s_div_dF2[2];
    for (int i = 0; i < dim; ++i) {
        for (int j = 0; j < dim; ++j) {
            d2s_div_dF2[0].row(i + j * dim) = dU_div_dF.row(i) * V(j, 0) + U(i, 0) * dV_div_dF.row(j);
            d2s_div_dF2[1].row(i + j * dim) = dU_div_dF.row(6 + i) * V(j, 2) + U(i, 2) * dV_div_dF.row(6 + j);
        }
    }

    T eps = 1e-6;
    Eigen::Matrix<T, dim * dim, dim * dim> d2s_div_dF2_FD[2];
    for (int rowI = 0; rowI < 3; ++rowI) {
        for (int colI = 0; colI < 3; ++colI) {
            MATRIX<T, dim> Fperturb = F;
            Fperturb(rowI, colI) += eps;

            MATRIX<T, dim> Up(1), Vp(1);
            VECTOR<T, dim> sigmap;
            Singular_Value_Decomposition(Fperturb, Up, sigmap, Vp);

            Eigen::Matrix<T, 2, 9> dS_div_dFp;
            for (int i = 0; i < dim; ++i) {
                for (int j = 0; j < dim; ++j) {
                    dS_div_dFp(0, i + j * dim) = Up(i, 0) * Vp(j, 0);
                    dS_div_dFp(1, i + j * dim) = Up(i, 2) * Vp(j, 2);
                }
            }
            
            d2s_div_dF2_FD[0].col(rowI + colI * 3) = (dS_div_dFp.row(0) - dS_div_dF.row(0)) / eps;
            d2s_div_dF2_FD[1].col(rowI + colI * 3) = (dS_div_dFp.row(1) - dS_div_dF.row(1)) / eps;
        }
    }

    printf("d2s0_div_dF2 error: %le %le\n", (d2s_div_dF2_FD[0] - d2s_div_dF2[0]).norm(), (d2s_div_dF2_FD[0] - d2s_div_dF2[0]).norm() / d2s_div_dF2_FD[0].norm());
    printf("d2s1_div_dF2 error: %le %le\n", (d2s_div_dF2_FD[1] - d2s_div_dF2[1]).norm(), (d2s_div_dF2_FD[1] - d2s_div_dF2[1]).norm() / d2s_div_dF2_FD[1].norm());
}

template<class T, int dim>
void Compute_BD_Hessian(
    MESH_ELEM<dim>& Elem, T h,
    T K, T stiffness,
    const std::vector<bool>& DBCb,
    MESH_NODE<T, dim>& X,
    MESH_NODE_ATTR<T, dim>& nodeAttr,
    MESH_ELEM_ATTR<T, dim>& elemAttr,
    FIXED_COROTATED<T, dim>& elasticityAttr,
    bool projectSPD,
    std::vector<Eigen::Triplet<T>>& triplets)
{
    TIMER_FLAG("Compute_BD_Hessian");
    if constexpr (dim == 2) {
        //TODO
    }
    else {
        std::vector<Eigen::Matrix<T, dim, dim>> U(Elem.size), V(Elem.size);
        std::vector<VECTOR<T, dim>> sigma(Elem.size);
        Elem.Par_Each([&](int id, auto data) {
            auto &[elemVInd] = data;
            if (!DBCb[elemVInd[0]] || !DBCb[elemVInd[1]] || !DBCb[elemVInd[2]] || !DBCb[elemVInd[3]]) {
                const VECTOR<T, dim>& x1 = std::get<0>(X.Get_Unchecked(elemVInd[0]));
                const VECTOR<T, dim>& x2 = std::get<0>(X.Get_Unchecked(elemVInd[1]));
                const VECTOR<T, dim>& x3 = std::get<0>(X.Get_Unchecked(elemVInd[2]));
                const VECTOR<T, dim>& x4 = std::get<0>(X.Get_Unchecked(elemVInd[3]));
                const MATRIX<T, dim>& IB = std::get<FIELDS<MESH_ELEM_ATTR<T, dim>>::IB>(elemAttr.Get_Unchecked(id));

                MATRIX<T, dim> A;
                for (int d = 0; d < 3; ++d) { 
                    A(d, 0) = x2[d] - x1[d];
                    A(d, 1) = x3[d] - x1[d];
                    A(d, 2) = x4[d] - x1[d];
                }
                MATRIX<T, dim> F = A * IB;
                MATRIX<T, dim> Ucur(1), Vcur(1);
                Singular_Value_Decomposition(F, Ucur, sigma[id], Vcur); //TODO: not redo everytime
                for (int i = 0; i < dim; ++i) {
                    for (int j = 0; j < dim; ++j) {
                        U[id](i, j) = Ucur(i, j);
                        V[id](i, j) = Vcur(i, j);
                    }
                }
            }
        });

        std::vector<int> elemTripletStartInd(Elem.size);
        int tripletStartInd = triplets.size();
        for (int i = 0; i < Elem.size; ++i) {
            const VECTOR<int, dim + 1>& elemVInd = std::get<0>(Elem.Get_Unchecked(i));
            if (!DBCb[elemVInd[0]] || !DBCb[elemVInd[1]] || !DBCb[elemVInd[2]] || !DBCb[elemVInd[3]])
            {
                elemTripletStartInd[i] = tripletStartInd;
                tripletStartInd += 144;
            }
            else {
                elemTripletStartInd[i] = -1;
            }
        }
        triplets.resize(tripletStartInd);

        Elem.Join(elasticityAttr).Par_Each([&](int id, auto data) {
            auto &[elemVInd, F_, vol, lambda, mu] = data;

            int startInd = elemTripletStartInd[id];
            if (startInd >= 0) {
                Eigen::Matrix<T, 2, 9> dS_div_dF;
                for (int i = 0; i < dim; ++i) {
                    for (int j = 0; j < dim; ++j) {
                        dS_div_dF(0, i + j * dim) = U[id](i, 0) * V[id](j, 0);
                        dS_div_dF(1, i + j * dim) = U[id](i, 2) * V[id](j, 2);
                    }
                }

                Eigen::Matrix<T, 9, 9> dU_div_dF;
                Eigen::Matrix<T, 9, 9> dV_div_dF;
                Compute_DU_And_DV_Div_DF<T>(U[id], sigma[id], V[id], dU_div_dF, dV_div_dF);

                Eigen::Matrix<T, 9, 9> d2s_div_dF2[2];
                for (int i = 0; i < dim; ++i) {
                    for (int j = 0; j < dim; ++j) {
                        d2s_div_dF2[0].row(i + j * dim) = dU_div_dF.row(i) * V[id](j, 0) + U[id](i, 0) * dV_div_dF.row(j);
                        d2s_div_dF2[1].row(i + j * dim) = dU_div_dF.row(6 + i) * V[id](j, 2) + U[id](i, 2) * dV_div_dF.row(6 + j);
                    }
                }

                T db_div_dS[2];
                Eigen::Matrix<T, 2, 2> d2b_div_dS2;
                g_bd<T>(K, sigma[id][0], sigma[id][2], db_div_dS);
                H_bd<T>(K, sigma[id][0], sigma[id][2], d2b_div_dS2.data());

                T weight = h * h * vol * stiffness;
                Eigen::Matrix<T, dim * dim, dim * dim> d2b_div_dF2;
                d2b_div_dF2 = dS_div_dF.transpose() * (weight * d2b_div_dS2) * dS_div_dF + 
                    weight * db_div_dS[0] * d2s_div_dF2[0] + weight * db_div_dS[1] * d2s_div_dF2[1];

                if (projectSPD) {
                    makePD(d2b_div_dF2);
                }

                const MATRIX<T, dim>& IB = std::get<FIELDS<MESH_ELEM_ATTR<T, dim>>::IB>(elemAttr.Get_Unchecked(id));
                Eigen::Matrix<T, 12, 9> intermediate;
                for (int colI = 0; colI < 9; ++colI) {
                    intermediate.col(colI).template segment<dim>(3) = IB(0, 0) * d2b_div_dF2.col(colI).template segment<dim>(0) + 
                        IB(0, 1) * d2b_div_dF2.col(colI).template segment<dim>(3) + IB(0, 2) * d2b_div_dF2.col(colI).template segment<dim>(6);
                    intermediate.col(colI).template segment<dim>(6) = IB(1, 0) * d2b_div_dF2.col(colI).template segment<dim>(0) + 
                        IB(1, 1) * d2b_div_dF2.col(colI).template segment<dim>(3) + IB(1, 2) * d2b_div_dF2.col(colI).template segment<dim>(6);
                    intermediate.col(colI).template segment<dim>(9) = IB(2, 0) * d2b_div_dF2.col(colI).template segment<dim>(0) + 
                        IB(2, 1) * d2b_div_dF2.col(colI).template segment<dim>(3) + IB(2, 2) * d2b_div_dF2.col(colI).template segment<dim>(6);
                    intermediate.col(colI).template segment<dim>(0) = -intermediate.col(colI).template segment<dim>(3) -
                        intermediate.col(colI).template segment<dim>(6) - intermediate.col(colI).template segment<dim>(9);
                }
                Eigen::Matrix<T, 12, 12> Hessian;
                for (int i = 0; i < 12; ++i) {
                    Hessian.row(i).template segment<dim>(3) = IB(0, 0) * intermediate.row(i).template segment<dim>(0) + 
                        IB(0, 1) * intermediate.row(i).template segment<dim>(3) + IB(0, 2) * intermediate.row(i).template segment<dim>(6);
                    Hessian.row(i).template segment<dim>(6) = IB(1, 0) * intermediate.row(i).template segment<dim>(0) + 
                        IB(1, 1) * intermediate.row(i).template segment<dim>(3) + IB(1, 2) * intermediate.row(i).template segment<dim>(6);
                    Hessian.row(i).template segment<dim>(9) = IB(2, 0) * intermediate.row(i).template segment<dim>(0) + 
                        IB(2, 1) * intermediate.row(i).template segment<dim>(3) + IB(2, 2) * intermediate.row(i).template segment<dim>(6);
                    Hessian.row(i).template segment<dim>(0) = -Hessian.row(i).template segment<dim>(3) - 
                        Hessian.row(i).template segment<dim>(6) - Hessian.row(i).template segment<dim>(9);
                }
                
                for (int i = 0; i < 4; ++i) {
                    for (int id = 0; id < dim; ++id) {
                        for (int j = 0; j < 4; ++j) {
                            for (int jd = 0; jd < dim; ++jd) {
                                triplets[startInd + (i * dim + id) * 12 + j * dim + jd] = std::move(
                                    Eigen::Triplet<T>(elemVInd[i] * dim + id, elemVInd[j] * dim + jd, 
                                    Hessian(i * dim + id, j * dim + jd)));
                            }
                        }
                    }
                }
            }
        });
    }
}

template <class T, int dim>
void Check_BD_Gradient(
    MESH_ELEM<dim>& Elem, T h,
    T K, T stiffness,
    const std::vector<bool>& DBCb,
    MESH_NODE<T, dim>& X,
    MESH_NODE_ATTR<T, dim>& nodeAttr,
    MESH_ELEM_ATTR<T, dim>& elemAttr,
    FIXED_COROTATED<T, dim>& elasticityAttr)
{
    T eps = 1.0e-6;

    T E0 = 0;
    Compute_BD_Energy(Elem, h, K, stiffness, DBCb, X, nodeAttr, elemAttr, elasticityAttr, E0); 
    nodeAttr.template Fill<FIELDS<MESH_NODE_ATTR<T, dim>>::g>(VECTOR<T, dim>(0));
    Compute_BD_Gradient(Elem, h, K, stiffness, DBCb, X, nodeAttr, elemAttr, elasticityAttr); 

    std::vector<T> grad_FD(X.size * dim);
    for (int i = 0; i < X.size * dim; ++i) {
        MESH_NODE<T, dim> Xperturb;
        Append_Attribute(X, Xperturb);
        std::get<0>(Xperturb.Get_Unchecked(i / dim))[i % dim] += eps;
        
        T E = 0;
        Compute_BD_Energy(Elem, h, K, stiffness, DBCb, Xperturb, nodeAttr, elemAttr, elasticityAttr, E); 
        grad_FD[i] = (E - E0) / eps;
    }

    T err = 0.0, norm = 0.0;
    nodeAttr.Each([&](int id, auto data) {
        auto &[x0, v, g, m] = data;

        err += std::pow(grad_FD[id * dim] - g[0], 2);
        err += std::pow(grad_FD[id * dim + 1] - g[1], 2);

        norm += std::pow(grad_FD[id * dim], 2);
        norm += std::pow(grad_FD[id * dim + 1], 2);

        if constexpr (dim == 3) {
            err += std::pow(grad_FD[id * dim + 2] - g[2], 2);
            norm += std::pow(grad_FD[id * dim + 2], 2);
        }
    });
    printf("err_abs = %le, err_rel = %le\n", err, err / norm);
}

template <class T, int dim>
void Check_BD_Hessian(
    MESH_ELEM<dim>& Elem, T h,
    T K, T stiffness,
    const std::vector<bool>& DBCb,
    MESH_NODE<T, dim>& X,
    MESH_NODE_ATTR<T, dim>& nodeAttr,
    MESH_ELEM_ATTR<T, dim>& elemAttr,
    FIXED_COROTATED<T, dim>& elasticityAttr)
{
    T eps = 1.0e-6;

    MESH_NODE_ATTR<T, dim> nodeAttr0;
    nodeAttr.deep_copy_to(nodeAttr0);
    nodeAttr0.template Fill<FIELDS<MESH_NODE_ATTR<T, dim>>::g>(VECTOR<T, dim>(0));
    Compute_BD_Gradient(Elem, h, K, stiffness, DBCb, X, nodeAttr0, elemAttr, elasticityAttr); 
    std::vector<Eigen::Triplet<T>> HStriplets;
    Compute_BD_Hessian(Elem, h, K, stiffness, DBCb, X, nodeAttr0, elemAttr, elasticityAttr, false, HStriplets); 
    CSR_MATRIX<T> HS;
    HS.Construct_From_Triplet(X.size * dim, X.size * dim, HStriplets);

    std::vector<Eigen::Triplet<T>> HFDtriplets;
    HFDtriplets.reserve(HStriplets.size());
    for (int i = 0; i < X.size * dim; ++i) {
        MESH_NODE<T, dim> Xperturb;
        Append_Attribute(X, Xperturb);
        std::get<0>(Xperturb.Get_Unchecked(i / dim))[i % dim] += eps;
        
        nodeAttr.template Fill<FIELDS<MESH_NODE_ATTR<T, dim>>::g>(VECTOR<T, dim>(0));
        Compute_BD_Gradient(Elem, h, K, stiffness, DBCb, Xperturb, nodeAttr, elemAttr, elasticityAttr); 
        for (int vI = 0; vI < X.size; ++vI) {
            const VECTOR<T, dim>& g = std::get<FIELDS<MESH_NODE_ATTR<T, dim>>::g>(nodeAttr.Get_Unchecked(vI));
            const VECTOR<T, dim>& g0 = std::get<FIELDS<MESH_NODE_ATTR<T, dim>>::g>(nodeAttr0.Get_Unchecked(vI));
            const VECTOR<T, dim> hFD = (g - g0) / eps;
            if (hFD.length2() > eps) {
                HFDtriplets.emplace_back(i, vI * dim, hFD[0]);
                HFDtriplets.emplace_back(i, vI * dim + 1, hFD[1]);
                if constexpr (dim == 3) {
                    HFDtriplets.emplace_back(i, vI * dim + 2, hFD[2]);
                }
            }
        }
    }
    CSR_MATRIX<T> HFD;
    HFD.Construct_From_Triplet(X.size * dim, X.size * dim, HFDtriplets);

    T err = (HS.Get_Matrix() - HFD.Get_Matrix()).squaredNorm(), norm = HFD.Get_Matrix().squaredNorm();
    printf("err_abs = %le, err_rel = %le\n", err, err / norm);
}

}